library(fitdistrplus) # for fitting Gumbel distribution
rm(list=ls())
cutoffVolume <- 8 # filter out particles less than this value (cubic microns)
umPerVoxel <- 0.500973555972 # voxel edge size from scan (microns)
cubicUmPerVoxel <- (umPerVoxel^3)
factorID <- c('scan01','scan02','scan03') # valid file name prefixes
factorDesc <-c('SE508','SE508ELI') # valid descriptions
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getSegmentation <- function(baseName, description){
# read volume information from histogram file
# total volume is about 0.42mm^3, of which 0.25mm^3 is matrix
# exact volumes vary depending on the mask used for each scan
histogram000 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=1,col_names=FALSE)
histogram255 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=256,col_names=FALSE)
voxels000 <- histogram000[[1,2]]
volume000 <- voxels000 * cubicUmPerVoxel
voxels255 <- histogram255[[1,2]]
volume255 <- voxels255 * cubicUmPerVoxel
totalVolume <- volume255 + volume000
matrixVolume <- volume255
# read morphology data (MorphoLibJ > Analysis > Particle Analysis 3D)
# organize into a new data table called morpho
morpho <- read_tsv(paste0('./image-data/',baseName,'-lbl-morpho.tsv'),col_names=TRUE)
# read bounding box data (MorphoLibJ > Analysis > Bounding Box 3D)
# convert voxels to microns and combine with morphology data
# add to morphology data table
bounds <- read_tsv(paste0('./image-data/',baseName,'-lbl-bounds.tsv'),col_names=TRUE) %>%
mutate(xBox = (XMax-XMin)*umPerVoxel,
yBox = (YMax-YMin)*umPerVoxel,
zBox = (ZMax-ZMin)*umPerVoxel) %>%
select(xBox,yBox,zBox)
morpho <- bind_cols(morpho,bounds)
# finally, add the total matrix volume in the last column
morpho <- morpho %>%
mutate(vMatrix = matrixVolume)
# prepend first and second columns to identify this data set
morpho <- morpho %>%
mutate(scanID = baseName,
scanDesc = description) %>%
select(scanID, scanDesc, everything(), -X1)
return(morpho)
}
xct <-      getSegmentation('scan01','SE508') %>%
bind_rows(getSegmentation('scan02','SE508ELI')) %>%
bind_rows(getSegmentation('scan03','SE508ELI')) %>%
filter(Volume > cutoffVolume) %>%
mutate(vPerCuMm = Volume / 1e9)
library(tidyverse)    # http://r4ds.had.co.nz/
library(fitdistrplus) # for fitting Gumbel distribution
rm(list=ls())
cutoffVolume <- 8 # filter out particles less than this value (cubic microns)
umPerVoxel <- 0.500973555972 # voxel edge size from scan (microns)
cubicUmPerVoxel <- (umPerVoxel^3)
factorID <- c('scan01','scan02','scan03') # valid file name prefixes
factorDesc <-c('SE508','SE508ELI') # valid descriptions
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getSegmentation <- function(baseName, description){
# read volume information from histogram file
# total volume is about 0.42mm^3, of which 0.25mm^3 is matrix
# exact volumes vary depending on the mask used for each scan
histogram000 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=1,col_names=FALSE)
histogram255 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=256,col_names=FALSE)
voxels000 <- histogram000[[1,2]]
volume000 <- voxels000 * cubicUmPerVoxel
voxels255 <- histogram255[[1,2]]
volume255 <- voxels255 * cubicUmPerVoxel
totalVolume <- volume255 + volume000
matrixVolume <- volume255
# read morphology data (MorphoLibJ > Analysis > Particle Analysis 3D)
# organize into a new data table called morpho
morpho <- read_tsv(paste0('./image-data/',baseName,'-lbl-morpho.tsv'),col_names=TRUE)
# read bounding box data (MorphoLibJ > Analysis > Bounding Box 3D)
# convert voxels to microns and combine with morphology data
# add to morphology data table
bounds <- read_tsv(paste0('./image-data/',baseName,'-lbl-bounds.tsv'),col_names=TRUE) %>%
mutate(xBox = (XMax-XMin)*umPerVoxel,
yBox = (YMax-YMin)*umPerVoxel,
zBox = (ZMax-ZMin)*umPerVoxel) %>%
select(xBox,yBox,zBox)
morpho <- bind_cols(morpho,bounds)
# finally, add the total matrix volume in the last column
morpho <- morpho %>%
mutate(vMatrix = matrixVolume)
# prepend first and second columns to identify this data set
morpho <- morpho %>%
mutate(scanID = baseName,
scanDesc = description) %>%
select(scanID, scanDesc, everything(), -X1)
return(morpho)
}
xct <-      getSegmentation('scan01','SE508') %>%
bind_rows(getSegmentation('scan02','SE508ELI')) %>%
bind_rows(getSegmentation('scan03','SE508ELI')) %>%
filter(Volume > cutoffVolume) %>%
mutate(vPerCuMm = Volume / 1e9)
library(fitdistrplus) # for fitting Gumbel distribution
library(tidyverse)    # http://r4ds.had.co.nz/
rm(list=ls())
cutoffVolume <- 8 # filter out particles less than this value (cubic microns)
umPerVoxel <- 0.500973555972 # voxel edge size from scan (microns)
cubicUmPerVoxel <- (umPerVoxel^3)
factorID <- c('scan01','scan02','scan03') # valid file name prefixes
factorDesc <-c('SE508','SE508ELI') # valid descriptions
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getSegmentation <- function(baseName, description){
# read volume information from histogram file
# total volume is about 0.42mm^3, of which 0.25mm^3 is matrix
# exact volumes vary depending on the mask used for each scan
histogram000 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=1,col_names=FALSE)
histogram255 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=256,col_names=FALSE)
voxels000 <- histogram000[[1,2]]
volume000 <- voxels000 * cubicUmPerVoxel
voxels255 <- histogram255[[1,2]]
volume255 <- voxels255 * cubicUmPerVoxel
totalVolume <- volume255 + volume000
matrixVolume <- volume255
# read morphology data (MorphoLibJ > Analysis > Particle Analysis 3D)
# organize into a new data table called morpho
morpho <- read_tsv(paste0('./image-data/',baseName,'-lbl-morpho.tsv'),col_names=TRUE)
# read bounding box data (MorphoLibJ > Analysis > Bounding Box 3D)
# convert voxels to microns and combine with morphology data
# add to morphology data table
bounds <- read_tsv(paste0('./image-data/',baseName,'-lbl-bounds.tsv'),col_names=TRUE) %>%
mutate(xBox = (XMax-XMin)*umPerVoxel,
yBox = (YMax-YMin)*umPerVoxel,
zBox = (ZMax-ZMin)*umPerVoxel) %>%
select(xBox,yBox,zBox)
morpho <- bind_cols(morpho,bounds)
# finally, add the total matrix volume in the last column
morpho <- morpho %>%
mutate(vMatrix = matrixVolume)
# prepend first and second columns to identify this data set
morpho <- morpho %>%
mutate(scanID = baseName,
scanDesc = description) %>%
select(scanID, scanDesc, everything(), -X1)
return(morpho)
}
xct <-      getSegmentation('scan01','SE508') %>%
bind_rows(getSegmentation('scan02','SE508ELI')) %>%
bind_rows(getSegmentation('scan03','SE508ELI')) %>%
filter(Volume > cutoffVolume) %>%
mutate(vPerCuMm = Volume / 1e9)
xct <- xct %>%
mutate(scanID = parse_factor(scanID, levels = factorID),
scanDesc = parse_factor(scanDesc, levels = factorDesc))
p.count <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID)) +
facet_grid(scanID ~ .) +
xlab('inclusion size (cubic micron)') +
ylab('inclusion count') +
ggtitle('inclusion count by size')
plot(p.count)
p.vol <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID,weight=Volume)) +
facet_grid(scanID ~ .) +
xlab('inclusion size (cubic micron)') +
ylab('sum of inclusion volume (cubic micron)') +
ggtitle('inclusion volume by size')
plot(p.vol)
p.count.ll <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID)) +
facet_grid(scanID ~ .) +
scale_y_log10() +
scale_x_log10(limits = c(1,NA)) +
xlab('inclusion size (cubic micron)') +
ylab('inclusion count') +
ggtitle('inclusion count by size')
plot(p.count.ll)
p.vol.ll <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID,weight=Volume)) +
facet_grid(scanID ~ .) +
scale_y_log10() +
scale_x_log10(limits = c(1,NA)) +
xlab('inclusion size (cubic micron)') +
ylab('sum of inclusion volume (cubic micron)') +
ggtitle('inclusion volume by size')
plot(p.vol.ll)
inclusionCount <- count(xct, scanID)
countByScan <- xct %>%
group_by(scanID,scanDesc) %>%
summarize(vMatrix = max(vMatrix)) %>%
bind_cols(inclusionCount[,2]) %>%
mutate(nPerUm3 = n/vMatrix,
nPerMm3 = nPerUm3 * 1e9)
print(countByScan)
countByDesc <- xct %>%
group_by(scanID,scanDesc) %>%
summarize(vMatrix = max(vMatrix)) %>%
bind_cols(inclusionCount[,2]) %>%
ungroup() %>%
group_by(scanDesc) %>%
summarize(vMatrix = sum(vMatrix),
n = sum(n)) %>%
mutate(nPerUm3 = n/vMatrix,
nPerMm3 = nPerUm3 * 1e9)
print(countByDesc)
dgumbel <- function(x,mu,s){ # PDF
exp((mu - x)/s - exp((mu - x)/s))/s
}
pgumbel <- function(q,mu,s){ # CDF
exp(-exp(-((q - mu)/s)))
}
qgumbel <- function(p, mu, s){ # quantile function
mu-s*log(-log(p))
}
xct.se508 <- filter(xct,scanDesc=='SE508')
xct.eli <- filter(xct,scanDesc=='SE508ELI')
gumbelFit <- function(vector){
fit <- fitdist(vector, "gumbel",
start=list(mu=4, s=1),
method="mle")
return(fit)
}
gumbel.se508.xz <- gumbelFit(xct.se508$rootXzArea)
library(fitdistrplus) # for fitting Gumbel distribution
library(tidyverse)    # http://r4ds.had.co.nz/
rm(list=ls())
cutoffVolume <- 8 # filter out particles less than this value (cubic microns)
umPerVoxel <- 0.500973555972 # voxel edge size from scan (microns)
cubicUmPerVoxel <- (umPerVoxel^3)
factorID <- c('scan01','scan02','scan03') # valid file name prefixes
factorDesc <-c('SE508','SE508ELI') # valid descriptions
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getSegmentation <- function(baseName, description){
# read volume information from histogram file
# total volume is about 0.42mm^3, of which 0.25mm^3 is matrix
# exact volumes vary depending on the mask used for each scan
histogram000 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=1,col_names=FALSE)
histogram255 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=256,col_names=FALSE)
voxels000 <- histogram000[[1,2]]
volume000 <- voxels000 * cubicUmPerVoxel
voxels255 <- histogram255[[1,2]]
volume255 <- voxels255 * cubicUmPerVoxel
totalVolume <- volume255 + volume000
matrixVolume <- volume255
# read morphology data (MorphoLibJ > Analysis > Particle Analysis 3D)
# organize into a new data table called morpho
morpho <- read_tsv(paste0('./image-data/',baseName,'-lbl-morpho.tsv'),col_names=TRUE)
# read bounding box data (MorphoLibJ > Analysis > Bounding Box 3D)
# convert voxels to microns and combine with morphology data
# add to morphology data table
bounds <- read_tsv(paste0('./image-data/',baseName,'-lbl-bounds.tsv'),col_names=TRUE) %>%
mutate(xBox = (XMax-XMin)*umPerVoxel,
yBox = (YMax-YMin)*umPerVoxel,
zBox = (ZMax-ZMin)*umPerVoxel) %>%
select(xBox,yBox,zBox)
morpho <- bind_cols(morpho,bounds)
# finally, add the total matrix volume in the last column
morpho <- morpho %>%
mutate(vMatrix = matrixVolume)
# prepend first and second columns to identify this data set
morpho <- morpho %>%
mutate(scanID = baseName,
scanDesc = description) %>%
select(scanID, scanDesc, everything(), -X1)
return(morpho)
}
xct <-      getSegmentation('scan01','SE508') %>%
bind_rows(getSegmentation('scan02','SE508ELI')) %>%
bind_rows(getSegmentation('scan03','SE508ELI')) %>%
filter(Volume > cutoffVolume) %>%
mutate(vPerCuMm = Volume / 1e9)
xct <- xct %>%
mutate(scanID = parse_factor(scanID, levels = factorID),
scanDesc = parse_factor(scanDesc, levels = factorDesc))
p.count <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID)) +
facet_grid(scanID ~ .) +
xlab('inclusion size (cubic micron)') +
ylab('inclusion count') +
ggtitle('inclusion count by size')
plot(p.count)
p.vol <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID,weight=Volume)) +
facet_grid(scanID ~ .) +
xlab('inclusion size (cubic micron)') +
ylab('sum of inclusion volume (cubic micron)') +
ggtitle('inclusion volume by size')
plot(p.vol)
p.count.ll <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID)) +
facet_grid(scanID ~ .) +
scale_y_log10() +
scale_x_log10(limits = c(1,NA)) +
xlab('inclusion size (cubic micron)') +
ylab('inclusion count') +
ggtitle('inclusion count by size')
plot(p.count.ll)
p.vol.ll <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID,weight=Volume)) +
facet_grid(scanID ~ .) +
scale_y_log10() +
scale_x_log10(limits = c(1,NA)) +
xlab('inclusion size (cubic micron)') +
ylab('sum of inclusion volume (cubic micron)') +
ggtitle('inclusion volume by size')
plot(p.vol.ll)
inclusionCount <- count(xct, scanID)
countByScan <- xct %>%
group_by(scanID,scanDesc) %>%
summarize(vMatrix = max(vMatrix)) %>%
bind_cols(inclusionCount[,2]) %>%
mutate(nPerUm3 = n/vMatrix,
nPerMm3 = nPerUm3 * 1e9)
print(countByScan)
countByDesc <- xct %>%
group_by(scanID,scanDesc) %>%
summarize(vMatrix = max(vMatrix)) %>%
bind_cols(inclusionCount[,2]) %>%
ungroup() %>%
group_by(scanDesc) %>%
summarize(vMatrix = sum(vMatrix),
n = sum(n)) %>%
mutate(nPerUm3 = n/vMatrix,
nPerMm3 = nPerUm3 * 1e9)
print(countByDesc)
source('~/R-workspace/nitinol-design-concepts/210-xct-methods/xct-process-imagej-results.R', echo=TRUE)
v.matl
v.plane
v.curoff
v.cutoff
v.nPerMm3
v.mu
v.s
dfGumbel
dfGumbel <- bind_cols(as_tibble(v.matl),as_tibble(v.plane),
as_tibble(v.cutoff),
as_tibble(v.nPerMm3), as_tibble(v.mu),as_tibble(v.s))
library(fitdistrplus) # for fitting Gumbel distribution
library(tidyverse)    # http://r4ds.had.co.nz/
rm(list=ls())
cutoffVolume <- 8 # filter out particles less than this value (cubic microns)
umPerVoxel <- 0.500973555972 # voxel edge size from scan (microns)
cubicUmPerVoxel <- (umPerVoxel^3)
factorID <- c('scan01','scan02','scan03') # valid file name prefixes
factorDesc <-c('SE508','SE508ELI') # valid descriptions
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getSegmentation <- function(baseName, description){
# read volume information from histogram file
# total volume is about 0.42mm^3, of which 0.25mm^3 is matrix
# exact volumes vary depending on the mask used for each scan
histogram000 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=1,col_names=FALSE)
histogram255 <- read_tsv(paste0('./image-data/',baseName,'-mask-histogram.tsv'),skip=256,col_names=FALSE)
voxels000 <- histogram000[[1,2]]
volume000 <- voxels000 * cubicUmPerVoxel
voxels255 <- histogram255[[1,2]]
volume255 <- voxels255 * cubicUmPerVoxel
totalVolume <- volume255 + volume000
matrixVolume <- volume255
# read morphology data (MorphoLibJ > Analysis > Particle Analysis 3D)
# organize into a new data table called morpho
morpho <- read_tsv(paste0('./image-data/',baseName,'-lbl-morpho.tsv'),col_names=TRUE)
# read bounding box data (MorphoLibJ > Analysis > Bounding Box 3D)
# convert voxels to microns and combine with morphology data
# add to morphology data table
bounds <- read_tsv(paste0('./image-data/',baseName,'-lbl-bounds.tsv'),col_names=TRUE) %>%
mutate(xBox = (XMax-XMin)*umPerVoxel,
yBox = (YMax-YMin)*umPerVoxel,
zBox = (ZMax-ZMin)*umPerVoxel) %>%
select(xBox,yBox,zBox)
morpho <- bind_cols(morpho,bounds)
# finally, add the total matrix volume in the last column
morpho <- morpho %>%
mutate(vMatrix = matrixVolume)
# prepend first and second columns to identify this data set
morpho <- morpho %>%
mutate(scanID = baseName,
scanDesc = description) %>%
select(scanID, scanDesc, everything(), -X1)
return(morpho)
}
xct <-      getSegmentation('scan01','SE508') %>%
bind_rows(getSegmentation('scan02','SE508ELI')) %>%
bind_rows(getSegmentation('scan03','SE508ELI')) %>%
filter(Volume > cutoffVolume) %>%
mutate(vPerCuMm = Volume / 1e9)
xct <- xct %>%
mutate(scanID = parse_factor(scanID, levels = factorID),
scanDesc = parse_factor(scanDesc, levels = factorDesc))
p.count <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID)) +
facet_grid(scanID ~ .) +
xlab('inclusion size (cubic micron)') +
ylab('inclusion count') +
ggtitle('inclusion count by size')
plot(p.count)
p.vol <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID,weight=Volume)) +
facet_grid(scanID ~ .) +
xlab('inclusion size (cubic micron)') +
ylab('sum of inclusion volume (cubic micron)') +
ggtitle('inclusion volume by size')
plot(p.vol)
p.count.ll <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID)) +
facet_grid(scanID ~ .) +
scale_y_log10() +
scale_x_log10(limits = c(1,NA)) +
xlab('inclusion size (cubic micron)') +
ylab('inclusion count') +
ggtitle('inclusion count by size')
plot(p.count.ll)
p.vol.ll <- ggplot(xct) +
geom_histogram(aes(Volume,fill=scanID,weight=Volume)) +
facet_grid(scanID ~ .) +
scale_y_log10() +
scale_x_log10(limits = c(1,NA)) +
xlab('inclusion size (cubic micron)') +
ylab('sum of inclusion volume (cubic micron)') +
ggtitle('inclusion volume by size')
plot(p.vol.ll)
inclusionCount <- count(xct, scanID)
countByScan <- xct %>%
group_by(scanID,scanDesc) %>%
summarize(vMatrix = max(vMatrix)) %>%
bind_cols(inclusionCount[,2]) %>%
mutate(nPerUm3 = n/vMatrix,
nPerMm3 = nPerUm3 * 1e9)
print(countByScan)
countByDesc <- xct %>%
group_by(scanID,scanDesc) %>%
summarize(vMatrix = max(vMatrix)) %>%
bind_cols(inclusionCount[,2]) %>%
ungroup() %>%
group_by(scanDesc) %>%
summarize(vMatrix = sum(vMatrix),
n = sum(n)) %>%
mutate(nPerUm3 = n/vMatrix,
nPerMm3 = nPerUm3 * 1e9)
print(countByDesc)
xct <- xct %>%
mutate(xyArea = Volume / zBox, # area projected in XY plane (transverse)
xzArea = Volume / yBox, # area projected in XZ plane (longitudinal)
yzArea = Volume / xBox, # area projected in YZ plane (longitudinal)
rootXyArea = xyArea^(1/2),
rootXzArea = xzArea^(1/2),
rootYzArea = yzArea^(1/2))
dgumbel <- function(x,mu,s){ # PDF
exp((mu - x)/s - exp((mu - x)/s))/s
}
pgumbel <- function(q,mu,s){ # CDF
exp(-exp(-((q - mu)/s)))
}
qgumbel <- function(p, mu, s){ # quantile function
mu-s*log(-log(p))
}
xct.se508 <- filter(xct,scanDesc=='SE508')
xct.eli <- filter(xct,scanDesc=='SE508ELI')
gumbelFit <- function(vector){
fit <- fitdist(vector, "gumbel",
start=list(mu=4, s=1),
method="mle")
return(fit)
}
gumbel.se508.xz <- gumbelFit(xct.se508$rootXzArea)
gumbel.se508.yz <- gumbelFit(xct.se508$rootYzArea)
gumbel.se508.xy <- gumbelFit(xct.se508$rootXyArea)
gumbel.eli.xz <- gumbelFit(xct.eli$rootXzArea)
gumbel.eli.yz <- gumbelFit(xct.eli$rootYzArea)
gumbel.eli.xy <- gumbelFit(xct.eli$rootXyArea)
par(cex=1.2, bg="white")
plot(gumbel.se508.xy, lwd=2, col="steelblue")
plot(gumbel.se508.yz, lwd=2, col="steelblue")
plot(gumbel.se508.xz, lwd=2, col="steelblue")
plot(gumbel.eli.xy, lwd=2, col="steelblue")
plot(gumbel.eli.yz, lwd=2, col="steelblue")
plot(gumbel.eli.xz, lwd=2, col="steelblue")
v.matl <- c(rep('se508',3),rep('eli',3))
n.SE508 <- countByDesc[countByDesc$scanDesc=='SE508','nPerMm3'][[1]]
n.SE508ELI <- countByDesc[countByDesc$scanDesc=='SE508ELI','nPerMm3'][[1]]
v.nPerMm3 <- c(rep(n.SE508,3),
rep(n.SE508ELI,3))
v.plane <- c(rep(c('xy','yz','xz'),3))
v.plane <- c(rep(c('xy','yz','xz'),2))
v.cutoff <- c(rep(cutoffVolume,6))
gumbelMu <- function(gumbelModel){
return(gumbelModel$estimate[[1]])
}
gumbelS <- function(gumbelModel){
return(gumbelModel$estimate[[2]])
}
v.mu <- c(gumbelMu(gumbel.se508.xy),
gumbelMu(gumbel.se508.yz),
gumbelMu(gumbel.se508.xz),
gumbelMu(gumbel.eli.xy),
gumbelMu(gumbel.eli.yz),
gumbelMu(gumbel.eli.xz))
v.s <- c(gumbelS(gumbel.se508.xy),
gumbelS(gumbel.se508.yz),
gumbelS(gumbel.se508.xz),
gumbelS(gumbel.eli.xy),
gumbelS(gumbel.eli.yz),
gumbelS(gumbel.eli.xz))
dfGumbel <- bind_cols(as_tibble(v.matl),as_tibble(v.plane),
as_tibble(v.cutoff),
as_tibble(v.nPerMm3), as_tibble(v.mu),as_tibble(v.s))
colnames(dfGumbel) <- c('matl', 'plane', 'cutoff', 'nPerMm3', 'mu', 's')
dir.create('./out/gumbel', showWarnings = FALSE)
write_csv(dfGumbel, path = paste('./out/','gumbelParameters',
'.csv',sep = ''), na='0')
dir.create('./out', showWarnings = FALSE)
write_csv(dfGumbel, path = paste('./out/','gumbelParameters',
'.csv',sep = ''), na='0')
source('~/R-workspace/nitinol-design-concepts/210-xct-methods/xct-process-imagej-results.R', echo=TRUE)
source('~/R-workspace/nitinol-design-concepts/210-xct-methods/xct-process-imagej-results.R', echo=TRUE)
print(countByDesc)
source('~/R-workspace/nitinol-design-concepts/210-xct-methods/xct-process-imagej-results.R', echo=TRUE)
bounds
source('~/R-workspace/nitinol-design-concepts/210-xct-methods/xct-process-imagej-results.R', echo=TRUE)
print(countByScan)
dfGumbel
